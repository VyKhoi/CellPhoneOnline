{"ast":null,"code":"import _slicedToArray from \"D:\\\\CELLPHONEONL\\\\SellPhonesOnline\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = function getScrollParent(node) {\n  var parent = node;\n  while (parent = parent.parentElement) {\n    var overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\") return parent;\n  }\n  return window;\n};\nvar isOffsetElement = function isOffsetElement(el) {\n  return el.firstChild ? el.firstChild.offsetParent === el : true;\n};\nvar offsetTill = function offsetTill(node, target) {\n  var current = node;\n  var offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = function getParentNode(node) {\n  var currentParent = node.parentElement;\n  while (currentParent) {\n    var style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\") break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  var opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get: function get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n  });\n  var emptyHandler = function emptyHandler() {};\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {}\nvar getDimensions = function getDimensions(opts) {\n  var el = opts.el,\n    onChange = opts.onChange,\n    unsubs = opts.unsubs,\n    measure = opts.measure;\n  if (el === window) {\n    var getRect = function getRect() {\n      return {\n        top: 0,\n        left: 0,\n        height: window.innerHeight,\n        width: window.innerWidth\n      };\n    };\n    var mResult = measure(getRect());\n    var handler = function handler() {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(function () {\n      return window.addEventListener(\"resize\", handler, passiveArg);\n    });\n    return mResult;\n  } else {\n    var _mResult = measure(el.getBoundingClientRect());\n    var _handler = function _handler() {\n      Object.assign(_mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    var ro = new ResizeObserver(_handler);\n    ro.observe(el);\n    unsubs.push(function () {\n      return ro.disconnect();\n    });\n    return _mResult;\n  }\n};\nvar getVerticalPadding = function getVerticalPadding(node) {\n  var computedParentStyle = getComputedStyle(node, null);\n  var parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  var parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return {\n    top: parentPaddingTop,\n    bottom: parentPaddingBottom\n  };\n};\nvar setup = function setup(node, unsubs, opts) {\n  var bottom = opts.bottom,\n    offsetBottom = opts.offsetBottom,\n    offsetTop = opts.offsetTop;\n  var scrollPane = getScrollParent(node);\n  var isScheduled = false;\n  var scheduleOnLayout = function scheduleOnLayout() {\n    if (!isScheduled) {\n      requestAnimationFrame(function () {\n        var nextMode = onLayout();\n        if (nextMode !== mode) changeMode(nextMode);\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  var latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  var isBoxTooLow = function isBoxTooLow(scrollY) {\n    var scrollPaneOffset = scrollPaneDims.offsetTop,\n      viewPortHeight = scrollPaneDims.height;\n    var naturalTop = parentDims.naturalTop;\n    var nodeHeight = nodeDims.height;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  var onLayout = function onLayout() {\n    var viewPortHeight = scrollPaneDims.height;\n    var nodeHeight = nodeDims.height;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n\n  var scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  var scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref) {\n      var height = _ref.height,\n        top = _ref.top;\n      return {\n        height: height,\n        offsetTop: scrollPaneIsOffsetEl ? top : 0\n      };\n    }\n  });\n  var parentNode = getParentNode(node);\n  var parentPaddings = parentNode === window ? {\n    top: 0,\n    bottom: 0\n  } : getVerticalPadding(parentNode);\n  var parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref2) {\n      var height = _ref2.height;\n      return {\n        height: height - parentPaddings.top - parentPaddings.bottom,\n        naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n      };\n    }\n  });\n  var nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref3) {\n      var height = _ref3.height;\n      return {\n        height: height\n      };\n    }\n  });\n  var relativeOffset = 0;\n  var mode = onLayout();\n  var changeMode = function changeMode(newMode) {\n    var prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */) relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = \"\".concat(offsetBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(offsetTop, \"px\");\n      }\n      return;\n    }\n    var viewPortHeight = scrollPaneDims.height,\n      scrollPaneOffset = scrollPaneDims.offsetTop;\n    var parentHeight = parentDims.height,\n      naturalTop = parentDims.naturalTop;\n    var nodeHeight = nodeDims.height;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n      if (bottom) {\n        var nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = \"\".concat(nextBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(relativeOffset, \"px\");\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = \"\".concat(offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(offsetTop, \"px\");\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  var onScroll = function onScroll(scrollY) {\n    if (scrollY === latestScrollY) return;\n    var scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */) return;\n    var scrollPaneOffset = scrollPaneDims.offsetTop,\n      viewPortHeight = scrollPaneDims.height;\n    var naturalTop = parentDims.naturalTop,\n      parentHeight = parentDims.height;\n    var nodeHeight = nodeDims.height;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          var topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY)) changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          var bottomOffset = Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n\n  var handleScroll = scrollPane === window ? function () {\n    return onScroll(window.scrollY);\n  } : function () {\n    return onScroll(scrollPane.scrollTop);\n  };\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(function () {\n    return scrollPane.removeEventListener(\"scroll\", handleScroll);\n  }, function () {\n    return scrollPane.removeEventListener(\"mousewheel\", handleScroll);\n  });\n};\nvar useStickyBox = function useStickyBox() {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref4$offsetTop = _ref4.offsetTop,\n    offsetTop = _ref4$offsetTop === void 0 ? 0 : _ref4$offsetTop,\n    _ref4$offsetBottom = _ref4.offsetBottom,\n    offsetBottom = _ref4$offsetBottom === void 0 ? 0 : _ref4$offsetBottom,\n    _ref4$bottom = _ref4.bottom,\n    bottom = _ref4$bottom === void 0 ? false : _ref4$bottom;\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    node = _useState2[0],\n    setNode = _useState2[1];\n  useEffect(function () {\n    if (!node || !stickyProp) return;\n    var unsubs = [];\n    setup(node, unsubs, {\n      offsetBottom: offsetBottom,\n      offsetTop: offsetTop,\n      bottom: bottom\n    });\n    return function () {\n      unsubs.forEach(function (fn) {\n        return fn();\n      });\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = function StickyBox(props) {\n  var offsetTop = props.offsetTop,\n    offsetBottom = props.offsetBottom,\n    bottom = props.bottom,\n    children = props.children,\n    className = props.className,\n    style = props.style;\n  var ref = useStickyBox({\n    offsetTop: offsetTop,\n    offsetBottom: offsetBottom,\n    bottom: bottom\n  });\n  return /* @__PURE__ */jsx(\"div\", {\n    className: className,\n    style: style,\n    ref: ref,\n    children: children\n  });\n};\nvar src_default = StickyBox;\nexport { src_default as default, useStickyBox };","map":null,"metadata":{},"sourceType":"module"}